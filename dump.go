package main

import (
	"crypto/sha1"
	"context"
	"encoding/hex"
	"encoding/json"
	"time"

	"cloud.google.com/go/datastore"
)

// UploadedFile stores metadata and the content of an uploaded file
type UploadedFile struct {
	Filename  string // The name of the file
	SHA1      string // The SHA1 Hash
	Content   []byte // The contents of the file
	ValueName string // The name of this value in the form
}

// UploadMultipartValue stores a key/value pair
type UploadMultipartValue struct {
	ValueName string // The name of this value in the form
	Content   []byte // The Content
}

// DatastoreDump is a representation of a Dump that serializes fields which datastore can't store to JSON.
type DatastoreDump struct {
	Timestamp       time.Time              // The time the dump happened
	Method          string                 // POST vs GET
	RemoteAddr      string                 // The IP Address of the incoming request
	ID              int64                  // The ID for this dump (as generated by datastore.AllocateIDs)
	HeaderBytes     []byte                 // The headers associated with this dump
	FormBytes       []byte                 // The post parameters for this dump
	Body            string                 // The body of the request
	Files           []UploadedFile         // The content of uploaded files
	MultipartValues []UploadMultipartValue // The content of multiplart values
}

// Dump is the dumped request that this entire service is built around
type Dump struct {
	Timestamp       time.Time              // The time the dump happened
	Method          string                 // POST vs GET
	RemoteAddr      string                 // The IP Address of the incoming request
	ID              int64                  // The ID for this dump (as generated by datastore.AllocateIDs)
	Headers         map[string][]string    // The key/value pairs passed in the headers
	FormValues      map[string][]string    // The actual post/get parameters
	Body            string                 // The body of the request
	Files           []UploadedFile         // The content of uploaded files
	MultipartValues []UploadMultipartValue // The content of multiplart values
}

// addHeader initializes the map if necessary and adds headers to it
func (d *Dump) addHeader(key string, value []string) {
	if d.Headers == nil {
		d.Headers = make(map[string][]string)
	}

	d.Headers[key] = value
}

// addMultipartValue adds a multipart value to the dump
func (d *Dump) addMultipartValue(valueName string, content []byte) {
	var newMultipartValue UploadMultipartValue
	newMultipartValue.ValueName = valueName
	newMultipartValue.Content = content
	d.MultipartValues = append(d.MultipartValues, newMultipartValue)
}

// addFile adds a file that was uploaded as multipart form upload to the dump
func (d *Dump) addFile(filename string, valueName string, content []byte) {
	var newFile UploadedFile
	newFile.Filename = filename
	newFile.Content = content
	newFile.ValueName = valueName
	h := sha1.New()
	h.Write(content)
	newFile.SHA1 = hex.EncodeToString(h.Sum(nil))
	d.Files = append(d.Files, newFile)
}

// Save converts the Dump into a DatastoreDump so it can be saved to the datastore
// This conversion includes converting complex fields into JSON strings
func (d *Dump) Save() ([]datastore.Property, error) {

	// serialize the non basic types
	headerJSONBytes, err := json.Marshal(d.Headers)
	if err != nil {
		return nil, err
	}

	formJSONBytes, err := json.Marshal(d.FormValues)
	if err != nil {
		return nil, err
	}

	dataToStore := new(DatastoreDump)
	dataToStore.Timestamp = d.Timestamp
	dataToStore.Method = d.Method
	dataToStore.RemoteAddr = d.RemoteAddr
	dataToStore.ID = d.ID
	dataToStore.HeaderBytes = headerJSONBytes
	dataToStore.FormBytes = formJSONBytes
	dataToStore.Body = d.Body
	dataToStore.Files = d.Files
	dataToStore.MultipartValues = d.MultipartValues

	return datastore.SaveStruct(dataToStore)
}

// Load Unserializes some fields in the dump so they can be restored
func (d *Dump) Load(ps []datastore.Property) error {
	dataFromStore := new(DatastoreDump)
	if err := datastore.LoadStruct(dataFromStore, ps); err != nil {
		return err
	}

	d.Timestamp = dataFromStore.Timestamp
	d.Method = dataFromStore.Method
	d.RemoteAddr = dataFromStore.RemoteAddr
	d.ID = dataFromStore.ID
	d.Body = dataFromStore.Body
	d.Files = dataFromStore.Files
	d.MultipartValues = dataFromStore.MultipartValues

	if err := json.Unmarshal(dataFromStore.HeaderBytes, &d.Headers); err != nil {
		return err
	}
	if err := json.Unmarshal(dataFromStore.FormBytes, &d.FormValues); err != nil {
		return err
	}

	return nil
}

// Makes this dump a child of a toilet and stores it returning the ID of the dump
func storeDump(context context.Context, client *datastore.Client, dump *Dump, toilet *Toilet) (int64, error) {
	// toiletKey := datastore.NewKey(context, "Toilet", toilet.ID, 0, nil)
	toiletKey := datastore.NameKey("Toilet", toilet.ID, nil)

	// We can't rely on Datastore to generate an ID at insert time because we need
	// the ID as part of the Dump
	var keys []*datastore.Key
	keys = append(keys, datastore.IncompleteKey("Dump", toiletKey))
	generatedKeys, err := client.AllocateIDs(context, keys)
	if err != nil {
		logError(context, "Unable to allocate new ID for dump", err)
		return 0, err
	}

	// Store the dump
	dump.ID = generatedKeys[0].ID
	key, err := client.Put(context, generatedKeys[0], dump)
	if err != nil {
		logError(context, "Unable to store dump", err)
		return 0, err
	}

	return key.ID, nil
}

// retrieves a dump from the data store
func getDump(context context.Context, client *datastore.Client, dumpID int64, toiletID string) (*Dump, error) {
	var dump Dump

	toiletKey := datastore.NameKey("Toilet", toiletID, nil)
	dumpKey := datastore.IDKey("Dump", dumpID, toiletKey)
	err := client.Get(context, dumpKey, &dump)
	if err != nil {
		if err == datastore.ErrNoSuchEntity {
			logMessage(context, "Unable to find dump")
			return nil, nil
		}

		logError(context, "Error getting dump.", err)
		return nil, err
	}

	return &dump, nil
}

// Deletes a specific dump
// Does not return an error if the dump does not exist
func deleteDump(context context.Context, client *datastore.Client, dumpID int64, toiletID string) error {
	toiletKey := datastore.NameKey("Toilet", toiletID, nil)
	dumpKey := datastore.IDKey("Dump", dumpID, toiletKey)
	
	return client.Delete(context, dumpKey)
}
