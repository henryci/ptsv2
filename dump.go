package ptsv2

import (
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"time"

	"golang.org/x/net/context"
	"google.golang.org/appengine/datastore"
)

// UploadedFile stores metadata and the content of an uploaded file
type UploadedFile struct {
	Filename string // The name of the file
	SHA1     string // The SHA1 Hash
	Content  []byte // The contents of the file
}

// DatastoreDump is a representation of a Dump that serializes fields
// Which datastore can't store to JSON.
type DatastoreDump struct {
	Timestamp   time.Time      // The time the dump happened
	Method      string         // POST vs GET
	RemoteAddr  string         // The IP Address of the incoming request
	ID          int64          // The ID for this dump (as generated by datastore.AllocateIDs)
	HeaderBytes []byte         // The headers associated with this dump
	FormBytes   []byte         // The post parameters for this dump
	Body        string         // The body of the request
	Files       []UploadedFile // The content of uploaded files
}

// Dump is the dumped request that this entire service is built around
type Dump struct {
	Timestamp  time.Time           // The time the dump happened
	Method     string              // POST vs GET
	RemoteAddr string              // The IP Address of the incoming request
	ID         int64               // The ID for this dump (as generated by datastore.AllocateIDs)
	Headers    map[string][]string // The key/value pairs passed in the headers
	FormValues map[string][]string // The actual post/get parameters
	Body       string              // The body of the request
	Files      []UploadedFile      // The content of uploaded files
}

// addHeader initializes the map if necessary and adds headers to it
func (d *Dump) addHeader(key string, value []string) {
	if d.Headers == nil {
		d.Headers = make(map[string][]string)
	}

	d.Headers[key] = value
}

// addFile adds a file that was uploaded as multipart form upload to the dump
func (d *Dump) addFile(filename string, content []byte) {
	var newFile UploadedFile
	newFile.Filename = filename
	newFile.Content = content
	h := sha1.New()
	h.Write(content)
	newFile.SHA1 = hex.EncodeToString(h.Sum(nil))
	d.Files = append(d.Files, newFile)
}

// Save converts the Dump into a DatastoreDump so it can be saved to the datastore
// This conversion includes converting complex fields into JSON strings
func (d *Dump) Save() ([]datastore.Property, error) {

	// serialize the non basic types
	headerJSONBytes, err := json.Marshal(d.Headers)
	if err != nil {
		return nil, err
	}

	formJSONBytes, err := json.Marshal(d.FormValues)
	if err != nil {
		return nil, err
	}

	dataToStore := new(DatastoreDump)
	dataToStore.Timestamp = d.Timestamp
	dataToStore.Method = d.Method
	dataToStore.RemoteAddr = d.RemoteAddr
	dataToStore.ID = d.ID
	dataToStore.HeaderBytes = headerJSONBytes
	dataToStore.FormBytes = formJSONBytes
	dataToStore.Body = d.Body
	dataToStore.Files = d.Files

	return datastore.SaveStruct(dataToStore)
}

// Load Unserializes some fields in the dump so they can be restored
func (d *Dump) Load(ps []datastore.Property) error {
	dataFromStore := new(DatastoreDump)
	if err := datastore.LoadStruct(dataFromStore, ps); err != nil {
		return err
	}

	d.Timestamp = dataFromStore.Timestamp
	d.Method = dataFromStore.Method
	d.RemoteAddr = dataFromStore.RemoteAddr
	d.ID = dataFromStore.ID
	d.Body = dataFromStore.Body
	d.Files = dataFromStore.Files

	if err := json.Unmarshal(dataFromStore.HeaderBytes, &d.Headers); err != nil {
		return err
	}
	if err := json.Unmarshal(dataFromStore.FormBytes, &d.FormValues); err != nil {
		return err
	}

	return nil
}

// Makes this dump a child of a toilet and stores it returning the ID of the dump
func storeDump(context context.Context, dump *Dump, toilet *Toilet) (int64, error) {
	toiletKey := datastore.NewKey(context, "Toilet", toilet.ID, 0, nil)

	// We can't rely on Datastore to generate an ID at insert time because we need
	// the ID as part of the Dump
	low, _, err := datastore.AllocateIDs(context, "Dump", toiletKey, 1)
	if err != nil {
		logError(context, "Unable to allocate new ID for dump", err)
		return 0, err
	}

	// Store the dump
	dump.ID = low
	dumpKey := datastore.NewKey(context, "Dump", "", dump.ID, toiletKey)
	key, err := datastore.Put(context, dumpKey, dump)
	if err != nil {
		logError(context, "Unable to store dump", err)
		return 0, err
	}

	return key.IntID(), nil
}

// retrieves a dump from the data store
func getDump(context context.Context, dumpID int64, toiletID string) (*Dump, error) {
	var dump Dump

	toiletKey := datastore.NewKey(context, "Toilet", toiletID, 0, nil)
	dumpKey := datastore.NewKey(context, "Dump", "", dumpID, toiletKey)
	err := datastore.Get(context, dumpKey, &dump)
	if err != nil {
		if err == datastore.ErrNoSuchEntity {
			logMessage(context, "Unable to find dump")
			return nil, nil
		}

		logError(context, "Error getting dump.", err)
		return nil, err
	}

	return &dump, nil
}

// Deletes a specific dump
// Does not return an error if the dump does not exist
func deleteDump(context context.Context, dumpID int64, toiletID string) error {
	toiletKey := datastore.NewKey(context, "Toilet", toiletID, 0, nil)
	dumpKey := datastore.NewKey(context, "Dump", "", dumpID, toiletKey)

	return datastore.Delete(context, dumpKey)
}
